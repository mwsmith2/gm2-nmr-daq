////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// MIDTFillGraph_SHPF                                                         //
//                                                                            //
// Begin_Html <!--
/*-->

<!--*/
// --> End_Html
//                                                                            //
//                                                                            //
// Please note: The following information is only correct after executing     //
// the ROMEBuilder.                                                           //
//                                                                            //
// This task accesses the following folders :                                 //
//     ODB                                                                    //
//                                                                            //
// This task contains the following graphs :                                  //
//    MyGraph_SHPF                                                            //
//                                                                            //
// The histograms/graph are created and saved automaticaly by the task.       //
//                                                                            //
// The following method can be used to get a handle of the histogram/graph :  //
//                                                                            //
// Get<Histogram/Graph Name>()                                                //
//                                                                            //
// For histogram/graph arrays use :                                           //
//                                                                            //
// Get<Histogram/Graph Name>At(Int_t index)                                   //
//                                                                            //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

/* Generated header file containing necessary includes                        */
#include "generated/MIDTFillGraph_SHPFGeneratedIncludes.h"

////////////////////////////////////////////////////////////////////////////////
/*  This header was generated by ROMEBuilder. Manual changes above the        *
 * following line will be lost next tvec ROMEBuilder is executed.             */
/////////////////////////////////////----///////////////////////////////////////

#include "generated/MIDAnalyzer.h"
#include "tasks/MIDTFillGraph_SHPF.h"
#include "ROMEiostream.h"
#include "TStyle.h"
#include "TROOT.h"
#include "TFile.h"
#include "TPad.h"
#include "TGraph.h"
#include "TGraph2D.h"
#include "TF2.h"
#include <TTree.h>
#include "ROMEODBOfflineDataBase.h"
#include "MIDODB.h"
#include <TBranch.h>
#include "TMath.h"
#include <vector>
#include "shim_structs.hh"
#include "shim_transforms.hh"
#include "fid.h"

const int shim_platform_size = sizeof(gm2::platform_t) / sizeof(uint);
static TFile *fTreeFile = NULL;
static TTree *fEventTree = NULL;
static gm2::platform_t platform;
static uint buffer[shim_platform_size];
std::vector<double> wvfm;
std::vector<double> tvec;

ClassImp(MIDTFillGraph_SHPF)

//______________________________________________________________________________
void MIDTFillGraph_SHPF::Init()
{
}

//______________________________________________________________________________
void MIDTFillGraph_SHPF::BeginOfRun()
{
  TString treeFile = "data-out/platform_tree_";
  treeFile += Form("%05i.root", gAnalyzer->GetODB()->GetRunNumber());
  
  fTreeFile = TFile::Open(treeFile.Data(), "RECREATE");   
  fTreeFile->cd();
  fEventTree = new TTree("t_shpf","Shimming Plaform Data");
  fEventTree->Branch("platform", &platform.sys_clock[0], gm2::platform_str);

  tvec.resize(SHORT_FID_LN);
  wvfm.resize(SHORT_FID_LN);
  double dt = 0.001;
  double t0 = 0.0;

  // Set the tvec vector.
  for (int i = 0; i < SHORT_FID_LN; ++i) {
    tvec[i] = i * dt + t0;
  }
}

//______________________________________________________________________________
void MIDTFillGraph_SHPF::Event()
{
  if (IsMyGraph_SHPFActive()) {

    if (gAnalyzer->GetMidasDAQ()->GetSHPFBankEntries() > 0) {

      // Fill the int buffer.;
      int N = gAnalyzer->GetMidasDAQ()->GetSHPFBankEntries();
      for (int i = 0; i < N; i++) {
        buffer[i] = gAnalyzer->GetMidasDAQ()->GetSHPFBankAt(i);
      }
      
      // Then cast it to a platform_t type.
      std::copy(&buffer[0], 
                &buffer[shim_platform_size],
                (int *)(&platform.sys_clock[0]));
      

      for (int ch = 0; ch < SHIM_PLATFORM_CH; ++ch) {
        
        // Re-analyze all the FIDs.
        
        for (int i = 0; i < SHORT_FID_LN; ++i) {
          wvfm[i] = platform.trace[ch][i];
        }
        
        fid::Fid myfid(wvfm, tvec);
        
        // Make sure we got an FID signal
        if (myfid.isgood()) {
          
          platform.snr[ch] = myfid.snr();
          platform.len[ch] = myfid.fid_time();
          platform.freq[ch] = myfid.CalcPhaseFreq();
          platform.ferr[ch] = myfid.freq_err();
          platform.method[ch] = (ushort)fid::Method::PH;
          platform.health[ch] = myfid.health();
          platform.freq_zc[ch] = myfid.CalcZeroCountFreq();
          platform.ferr_zc[ch] = myfid.freq_err();
        
        } else {
       
          platform.snr[ch] = 0.0;
          platform.len[ch] = 0.0;
          platform.freq[ch] = 0.0;
          platform.ferr[ch] = 0.0;
          platform.method[ch] = (ushort)fid::Method::PH;
          platform.health[ch] = myfid.health();
          platform.freq_zc[ch] = 0.0;
          platform.ferr_zc[ch] = 0.0;
        }
      }

      // Now deal with probe mapping issues that we had early on.
      int run_number = gAnalyzer->GetODB()->GetRunNumber();

      if (run_number < 1475) {

        // Copy the original platform data.
        gm2::platform_t p = platform; 

        gm2::platform_t p_blank;
        p_blank.health[0];

        for (int j = 0; j < SHIM_PLATFORM_CH; ++j) {

          switch (j) 
            {
            case 2:
              gm2::platform_copy_channel(platform, j, p, 8);
              break;
            case 3:
              gm2::platform_copy_channel(platform, j, p, 20);
              break;
            case 6:
              gm2::platform_copy_channel(platform, j, p, 3);
              break;
            case 7:
              gm2::platform_copy_channel(platform, j, p, 10);
              break;
            case 8:
              gm2::platform_copy_channel(platform, j, p, 18);
              break;
            case 10:
              gm2::platform_copy_channel(platform, j, p, 14);
              break;
            case 14:
              gm2::platform_copy_channel(platform, j, p, 6);
              break;
            case 17:
              gm2::platform_copy_channel(platform, j, p, 7);
              break;
            case 18:
              gm2::platform_copy_channel(platform, j, p_blank, 0);
              break;
            case 20:
              gm2::platform_copy_channel(platform, j, p, 17);
              break;
            default:
              break;
            }
        }

      } else if (run_number == 1654) {
      
        // This run had an off by one problem in the sequencing,
        // so I'm hardcoding the permutation back.

        cout << "Remapping sequence for run 1654" << endl;

        gm2::platform_t p = platform; 

        // gm2::platform_copy_channel(platform, 0, p, 4);
        // gm2::platform_copy_channel(platform, 1, p, 16);
        // gm2::platform_copy_channel(platform, 2, p, 1);
        // gm2::platform_copy_channel(platform, 3, p, 2);
        // gm2::platform_copy_channel(platform, 4, p, 3);
        // gm2::platform_copy_channel(platform, 5, p, 24);
        // gm2::platform_copy_channel(platform, 6, p, 5);
        // gm2::platform_copy_channel(platform, 7, p, 6);
        // gm2::platform_copy_channel(platform, 8, p, 7);
        // gm2::platform_copy_channel(platform, 9, p, 27);
        // gm2::platform_copy_channel(platform, 10, p, 9);
        // gm2::platform_copy_channel(platform, 11, p, 10);
        // gm2::platform_copy_channel(platform, 12, p, 11);
        // gm2::platform_copy_channel(platform, 13, p, 12);
        // gm2::platform_copy_channel(platform, 14, p, 13);
        // gm2::platform_copy_channel(platform, 15, p, 14);
        // gm2::platform_copy_channel(platform, 16, p, 15);
        // gm2::platform_copy_channel(platform, 17, p, 26);
        // gm2::platform_copy_channel(platform, 18, p, 17);
        // gm2::platform_copy_channel(platform, 19, p, 18);
        // gm2::platform_copy_channel(platform, 20, p, 19);
        // gm2::platform_copy_channel(platform, 21, p, 20);
        // gm2::platform_copy_channel(platform, 22, p, 21);
        // gm2::platform_copy_channel(platform, 23, p, 22);
        // gm2::platform_copy_channel(platform, 24, p, 23);
        // gm2::platform_copy_channel(platform, 25, p, 8);
        // gm2::platform_copy_channel(platform, 26, p, 25);
        // gm2::platform_copy_channel(platform, 27, p, 0);

        gm2::platform_copy_channel(platform, 0, p, 27);
        gm2::platform_copy_channel(platform, 1, p, 2);
        gm2::platform_copy_channel(platform, 2, p, 3);
        gm2::platform_copy_channel(platform, 3, p, 4);
        gm2::platform_copy_channel(platform, 4, p, 0);
        gm2::platform_copy_channel(platform, 5, p, 6);
        gm2::platform_copy_channel(platform, 6, p, 7);
        gm2::platform_copy_channel(platform, 7, p, 8);
        gm2::platform_copy_channel(platform, 8, p, 25);
        gm2::platform_copy_channel(platform, 9, p, 10);
        gm2::platform_copy_channel(platform, 10, p, 11);
        gm2::platform_copy_channel(platform, 11, p, 12);
        gm2::platform_copy_channel(platform, 12, p, 13);
        gm2::platform_copy_channel(platform, 13, p, 14);
        gm2::platform_copy_channel(platform, 14, p, 15);
        gm2::platform_copy_channel(platform, 15, p, 16);
        gm2::platform_copy_channel(platform, 16, p, 1);
        gm2::platform_copy_channel(platform, 17, p, 18);
        gm2::platform_copy_channel(platform, 18, p, 19);
        gm2::platform_copy_channel(platform, 19, p, 20);
        gm2::platform_copy_channel(platform, 20, p, 21);
        gm2::platform_copy_channel(platform, 21, p, 22);
        gm2::platform_copy_channel(platform, 22, p, 23);
        gm2::platform_copy_channel(platform, 23, p, 24);
        gm2::platform_copy_channel(platform, 24, p, 5);
        gm2::platform_copy_channel(platform, 25, p, 26);
        gm2::platform_copy_channel(platform, 26, p, 17);
        gm2::platform_copy_channel(platform, 27, p, 9);
      }

      // Fill the TTree.
      fEventTree->Fill();
    }
  }
}

//______________________________________________________________________________
void MIDTFillGraph_SHPF::EndOfRun()
{
  fTreeFile->Write();
  fTreeFile->Close();
}

//______________________________________________________________________________
void MIDTFillGraph_SHPF::Terminate()
{
}

